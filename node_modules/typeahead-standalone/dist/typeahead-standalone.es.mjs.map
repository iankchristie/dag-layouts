{"version":3,"file":"typeahead-standalone.es.mjs","sources":["../src/helpers.ts","../src/fetchWrapper/fetchWrapper.ts","../src/trie/trie.ts","../src/typeahead-standalone.ts"],"sourcesContent":["import type { Dictionary } from './common.d.ts';\n\nexport const NOOP = (...args: unknown[]): void => undefined;\n\nexport const escapeRegExp = (text: string): string => text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\nexport const isObject = (item: unknown): boolean => {\n  return item !== null && (item as Dictionary)?.constructor.name === 'Object';\n};\n\n/** @deprecated */\nexport const deduplicateArr = (iterable: Dictionary[], prop: string): Dictionary[] => [\n  ...new Map(iterable.map((item) => [item[prop], item])).values(),\n];\n\nexport const diacritics = (txt = '') => txt.normalize('NFD').replace(/\\p{Diacritic}/gu, '');\n\n/****** helpers specific to typeahead  *****/\n\nexport const normalizer = <T extends Dictionary>(listItems: string[] | Dictionary[] | T[], identifier: string): T[] => {\n  const length = listItems.length;\n  if (!length) return [];\n\n  // validate array of objects\n  if (isObject(listItems[0])) {\n    // verify if identifier exists (i.e. normalized already)\n    for (let x = 0; x < length; x++) {\n      if (!(identifier in (listItems[x] as Dictionary))) {\n        throw new Error('e03');\n      }\n    }\n    return listItems as T[];\n  }\n\n  // normalize array of strings\n  const normalizedData = (listItems as []).reduce(function (acc: Record<string, unknown>[], currentItem) {\n    acc.push({\n      [identifier]: currentItem && typeof currentItem === 'string' ? currentItem : JSON.stringify(currentItem),\n    });\n    return acc;\n  }, []);\n\n  return normalizedData as T[];\n};\n\n/****** helpers specific to Trie  *****/\n\nexport const spaceTokenizer = (tokenString: string): string[] => tokenString.trim().split(/\\s+/);\n","// A custom FETCH API wrapper\n// inspired by https://jasonwatmore.com/post/2020/04/18/fetch-a-lightweight-fetch-wrapper-to-simplify-http-requests\n\nconst get = async function (url: RequestInfo | URL, requestOptions?: RequestInit): Promise<any> {\n  const response = await fetch(\n    url,\n    requestOptions || {\n      method: 'GET',\n    }\n  );\n  return handleResponse(response);\n};\n\n// helper function\nconst handleResponse = async function (response: Response) {\n  const text = await response.text();\n  const data = text && JSON.parse(text);\n  if (!response.ok) {\n    return Promise.reject((data && data.message) || response.statusText);\n  }\n  return data;\n};\n\nexport const fetchWrapper = {\n  get,\n};\n\n/*\n * @deprecated: Post method not required at the moment\n */\n// const post = async function (url: string, body: unknown): Promise<any> {\n//   const requestOptions = {\n//     method: 'POST',\n//     headers: { 'Content-Type': 'application/json' },\n//     body: JSON.stringify(body),\n//   };\n//   const response = await fetch(url, requestOptions);\n//   return handleResponse(response);\n// };\n","import type { Dictionary } from '../common.d.ts';\nimport type { SearchResults, TrieType } from './types.d.ts';\nimport { spaceTokenizer, diacritics } from '../helpers.js';\n\n// Trie algorithm (inspired by data structures @https://github.com/Yomguithereal/mnemonist)\nexport const Trie: TrieType<any> = (config = {}) => {\n  const { hasDiacritics } = config;\n  let root: Record<string, unknown> = {};\n\n  // marks the end of a string\n  const SENTINEL = String.fromCharCode(0);\n\n  /**\n   * Returns data/query tokens\n   */\n  function tokenize(value = '') {\n    value = `${value}`; // coerce to string\n\n    if (hasDiacritics) {\n      value = diacritics(value);\n    }\n    // make search case insensitive\n    return spaceTokenizer(value.toLowerCase());\n  }\n\n  /**\n   * Method used to add the given data to the trie.\n   * Identifier is optional when data is a string|string[], but mandatory for Dictionary[]\n   */\n  function add(data: string | string[] | Dictionary[], identifier = '', identity?: (item?: unknown) => void) {\n    if (!data) return;\n\n    let node = root;\n    let token;\n    data = (data.constructor === Array ? data : [data]) as [];\n\n    data.forEach((value: string | Dictionary) => {\n      // we tokenize the incoming data to make search possible by fragments\n      const dataTokens = tokenize(typeof value === 'string' ? value : (value[identifier] as string));\n      dataTokens\n        .filter((item) => item) // filter out falsy values\n        .forEach((prefix) => {\n          node = root;\n\n          for (let i = 0, l = prefix.length; i < l; i++) {\n            token = prefix[i];\n            node = (node[token] || (node[token] = {})) as Record<string, unknown>;\n          }\n\n          const uniqueId = typeof value === 'string' ? value : (identity && identity(value)) || JSON.stringify(value);\n\n          if (!node[SENTINEL]) {\n            node[SENTINEL] = {\n              [uniqueId]: value,\n            };\n          } else {\n            (node[SENTINEL] as Dictionary)[uniqueId] = value;\n          }\n        });\n    });\n  }\n\n  /**\n   * Internal Method used to retrieve items in the trie beginning with the given prefix.\n   */\n  function find(prefix: string): Dictionary {\n    let node = root;\n    let matches: Dictionary = {};\n    let token;\n\n    // traverse the root until you reach the end of prefix\n    for (let i = 0, l = prefix.length; i < l; i++) {\n      token = prefix[i]; // each letter of search string\n      node = node[token] as Record<string, unknown>;\n      if (typeof node === 'undefined') return {};\n    }\n\n    // Performing DFS (Depth-First Search) from prefix to traverse the tree\n    const nodeStack = [node];\n    const prefixStack = [prefix];\n    let k;\n\n    while (nodeStack.length) {\n      prefix = prefixStack.pop() as string;\n      node = nodeStack.pop() as Record<string, unknown>;\n\n      for (k in node) {\n        if (k === SENTINEL) {\n          matches = Object.assign(matches, node[SENTINEL]);\n          continue;\n        }\n\n        nodeStack.push(node[k] as Record<string, unknown>);\n        prefixStack.push(prefix + k);\n      }\n    }\n\n    return matches as Dictionary;\n  }\n\n  /**\n   * Search for query strings within the trie\n   */\n  function search(query: string, limit?: number): SearchResults<Dictionary | string> {\n    const queryTokens = tokenize(query);\n\n    // Search for multiple tokens/queries\n    const objArrs: Dictionary[] = [];\n    let suggestions: Dictionary | Dictionary[] = {};\n    queryTokens.forEach((token) => {\n      // note that limit is not passed to \"find()\"\n      objArrs.push(find(token) as Dictionary);\n    });\n\n    // get intersection of found suggestions\n    suggestions = objArrs.reduce((acc: Dictionary, currentObj: Dictionary) => {\n      const result: Dictionary = {};\n\n      Object.keys(acc)\n        .filter((key: string) => currentObj[key]) // keep suggestions with common keys\n        .forEach((key) => {\n          result[key] = acc[key];\n        });\n\n      return result;\n    });\n\n    suggestions = Object.values(suggestions) as Dictionary[];\n\n    const count = suggestions.length;\n\n    // truncate suggestions to limit\n    if (limit && count > limit) {\n      suggestions.length = limit;\n    }\n\n    return {\n      suggestions,\n      count,\n    };\n  }\n\n  function clear() {\n    root = {};\n  }\n\n  return {\n    add,\n    clear,\n    search,\n  };\n};\n","/*\n * https://github.com/digitalfortress-tech/typeahead-standalone\n * Copyright (c) 2020 Niket Pathak\n * MIT License\n */\n\nimport type {\n  typeaheadResult,\n  typeaheadConfig,\n  typeaheadHtmlTemplates,\n  Dictionary,\n  LocalDataSource,\n  RemoteDataSource,\n  PrefetchDataSource,\n  ResultSet,\n  typeaheadStyleClasses,\n} from './common.d.ts';\nimport { diacritics, escapeRegExp, isObject, NOOP, normalizer } from './helpers.js';\nimport { fetchWrapper } from './fetchWrapper/fetchWrapper.js';\nimport { Trie } from './trie/trie.js';\nimport './style.less';\n\nexport default function typeahead<T extends Dictionary>(config: typeaheadConfig<T>): typeaheadResult<T> {\n  // check required params\n  if (!config.input) throw new Error('e01');\n  if (!isObject(config.source)) throw new Error('e02');\n\n  const doc = document;\n\n  const listContainer: HTMLDivElement = doc.createElement('div');\n  const debounceXHR = config.debounceRemote || 100;\n  const preventSubmit = config.preventSubmit || false;\n  const minLen = config.minLength || 1;\n  const hint = config.hint === false ? false : true;\n  const autoSelect = config.autoSelect || false;\n  const templates: typeaheadHtmlTemplates<T> | undefined = config.templates;\n  const trie = Trie({ hasDiacritics: config.diacritics });\n  const identifier = config.source.identifier || 'label'; // label is the default identifier\n  const groupIdentifier = config.source.groupIdentifier || '';\n  const displayCb = <T extends Dictionary>(item: T): string => {\n    return `${item[identifier]}`;\n  };\n  const display: (item: T, e?: MouseEvent | KeyboardEvent | null) => string = config.display || displayCb;\n  const identity = config.source.identity || displayCb;\n  const onSubmit: (e: Event, item?: T) => void = config.onSubmit || NOOP;\n  const dataTokens = config.source.dataTokens?.constructor === Array ? config.source.dataTokens : undefined;\n  const transform = config.source.transform || ((data) => data);\n  const local = (config.source as LocalDataSource<T>).local || null;\n  const remoteUrlType = typeof (config.source as RemoteDataSource<T>).remote?.url;\n  const remote =\n    remoteUrlType === 'function' ||\n    (remoteUrlType === 'string' && (config.source as RemoteDataSource<T>).remote.wildcard)\n      ? (config.source as RemoteDataSource<T>).remote\n      : null;\n  const prefetch = (config.source as PrefetchDataSource<T>).prefetch?.url\n    ? { ...{ when: 'onInit', done: false }, ...(config.source as PrefetchDataSource<T>).prefetch }\n    : null;\n  const classNames: typeaheadStyleClasses = {\n    wrapper: '',\n    input: 'tt-input',\n    hint: 'tt-hint',\n    highlight: 'tt-highlight',\n    hide: 'tt-hide',\n    show: 'tt-show',\n    list: 'tt-list',\n    selected: 'tt-selected',\n    header: 'tt-header',\n    footer: 'tt-footer',\n    loader: 'tt-loader',\n    suggestion: 'tt-suggestion',\n    group: 'tt-group',\n    empty: 'tt-empty',\n    notFound: 'tt-notFound',\n    ...(config.classNames || {}),\n  };\n\n  // validate presence of atleast one data-source\n  if (!local && !prefetch && !remote) throw new Error('e02');\n\n  const resultSet: ResultSet<T> = {\n    query: '',\n    items: [], // suggestions\n    count: 0,\n    limit: config.limit || 5,\n  };\n\n  let remoteQueryCache: Dictionary = {};\n  let remoteResponseCache: Dictionary = {};\n\n  let selected: T | undefined;\n  let remoteDebounceTimer: number | undefined;\n  let fetchInProgress = false;\n  let storedInput = ''; // used only for keyboard navigation\n\n  // init templates if they exist\n  if (templates) {\n    templates.header = typeof templates.header === 'function' ? templates.header : undefined;\n    templates.footer = typeof templates.footer === 'function' ? templates.footer : undefined;\n    templates.notFound = typeof templates.notFound === 'function' ? templates.notFound : undefined;\n    templates.group = typeof templates.group === 'function' ? templates.group : undefined;\n    templates.suggestion = typeof templates.suggestion === 'function' ? templates.suggestion : undefined;\n    templates.loader = typeof templates.loader === 'function' ? templates.loader : undefined;\n    templates.empty = typeof templates.empty === 'function' ? templates.empty : undefined;\n  }\n\n  const addToIndex = (suggestions: string[] | Dictionary[] | T[] = []) => {\n    updateSearchIndex(normalizer(suggestions, identifier) as T[]);\n  };\n\n  // if local source exists, add the suggestions to the index\n  local && addToIndex(local);\n\n  const input: HTMLInputElement = config.input;\n  input.classList.add(classNames.input);\n  const computedInputStyle = window.getComputedStyle(input);\n\n  // Wrapper element\n  const wrapper: HTMLDivElement = doc.createElement('div');\n  // @deprecated config.className @todo: remove in v5\n  wrapper.className = `typeahead-standalone${config.className ? ` ${config.className}` : ''}${\n    classNames.wrapper ? ` ${classNames.wrapper}` : ''\n  }`;\n  resultSet.container = wrapper;\n\n  // move input element into the wrapper element\n  const parentEl = input.parentNode as HTMLElement;\n  const inputIndex = [...parentEl.children].indexOf(input);\n  parentEl.removeChild(input);\n  wrapper.appendChild(input);\n\n  // append Wrapper element to the original parent\n  parentEl.insertBefore(wrapper, parentEl.children[inputIndex]);\n\n  // generate markup for hints\n  const inputHint: HTMLInputElement = input.cloneNode() as HTMLInputElement;\n  hint && injectHintEl(inputHint);\n\n  listContainer.classList.add(classNames.list, classNames.hide);\n  listContainer.tabIndex = 0;\n  listContainer.setAttribute('aria-label', 'menu-options');\n  listContainer.setAttribute('role', 'listbox');\n\n  // set listContainer positioning\n  listContainer.style.position = 'absolute'; // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\n  listContainer.style.width = `${input.offsetWidth}px`;\n  listContainer.style.marginTop = `${input.offsetHeight + parseInt(computedInputStyle.marginTop)}px`;\n\n  // Attach list container\n  wrapper.appendChild(listContainer);\n\n  if (prefetch && prefetch.when === 'onInit') {\n    prefetchData();\n  }\n\n  function prefetchData() {\n    // check if data was already prefetched for current session\n    if (!prefetch || prefetch.done) return;\n\n    let transformed: T[] = [];\n\n    fetchWrapper\n      .get(typeof prefetch.url === 'function' ? prefetch.url() : prefetch.url, prefetch?.requestOptions)\n      .then(\n        (data) => {\n          transformed = transform(data) as T[];\n          transformed = normalizer(transformed, identifier) as T[];\n          updateSearchIndex(transformed);\n        },\n        (reject) => {\n          console.error('e04', reject);\n        }\n      )\n      .finally(() => {\n        typeof prefetch.process === 'function' && prefetch.process(transformed);\n      });\n\n    prefetch.done = true;\n  }\n\n  /**\n   * Display/show the listContainer\n   */\n  const show = (): void => {\n    listContainer.classList.remove(classNames.hide);\n  };\n\n  /**\n   * Hides the listContainer from DOM\n   */\n  const hide = (): void => {\n    listContainer.classList.add(classNames.hide);\n  };\n\n  /**\n   * Flag to indicate if the list of suggestions is open or not\n   * @returns Boolean\n   */\n  const isListOpen = (): boolean => !listContainer.classList.contains(classNames.hide);\n\n  /**\n   * Clear remote debounce timer if assigned\n   */\n  const clearRemoteDebounceTimer = (): void => {\n    if (remoteDebounceTimer) {\n      window.clearTimeout(remoteDebounceTimer);\n    }\n  };\n\n  /**\n   * Clear typeahead state and hide listContainer\n   */\n  const clear = (): void => {\n    resultSet.items = [];\n    inputHint.value = '';\n    storedInput = '';\n    hide();\n  };\n\n  /*\n   * Triggers a user input event\n   */\n  const emitInputEvent = (): void => {\n    input.dispatchEvent(\n      new InputEvent('input', {\n        bubbles: true,\n        inputType: 'insertCompositionText',\n        data: input.value,\n      })\n    );\n  };\n\n  /**\n   * Displays the NotFound template if it exists, otherwise, does nothing (i.e. returns true)\n   * @param asyncRender set to true for asyncRenders\n   * @returns true if no suggestions are found, else returns undefined\n   */\n  const noSuggestionsHandler = (asyncRender = false) => {\n    if (!resultSet.items.length && resultSet.query) {\n      // clear the list and the DOM\n      clear();\n      clearListDOM();\n\n      const notFoundTemplateHtml = templates?.notFound && templates.notFound(resultSet);\n      if (!notFoundTemplateHtml) return true;\n\n      const renderNotFoundTemplate = (html: string) => {\n        const notFoundEl = doc.createElement('div');\n        notFoundEl.classList.add(classNames.notFound);\n        templatify(notFoundEl, html);\n        listContainer.appendChild(notFoundEl);\n      };\n\n      if (!remote) {\n        renderNotFoundTemplate(notFoundTemplateHtml);\n      } else if (remoteQueryCache[JSON.stringify(resultSet.query)] || (asyncRender && !fetchInProgress)) {\n        // wait for remote results before rendering notFoundTemplate / render immediately if request was cached\n        renderNotFoundTemplate(notFoundTemplateHtml);\n      }\n\n      show();\n      return true;\n    }\n  };\n\n  /**\n   * Delete all children from typeahead DOM listContainer\n   */\n  const clearListDOM = () => {\n    while (listContainer.firstChild) {\n      listContainer.firstChild.remove();\n    }\n  };\n\n  const loader = () => {\n    if (!templates?.loader) {\n      return;\n    }\n\n    if (!fetchInProgress) {\n      const loaderEl = listContainer.querySelector(`.${classNames.loader}`);\n      loaderEl && listContainer.removeChild(loaderEl);\n      return;\n    }\n\n    // display spinner/loader\n    const loaderDiv = doc.createElement('div');\n    loaderDiv.classList.add(classNames.loader);\n    templatify(loaderDiv, templates.loader());\n    if (templates?.footer) {\n      listContainer.insertBefore(loaderDiv, listContainer.querySelector(`.${classNames.footer}`));\n    } else {\n      listContainer.appendChild(loaderDiv);\n    }\n  };\n\n  /**\n   * Responsible for drawing/updating the view\n   */\n  const update = (): void => {\n    // No Matches\n    if (noSuggestionsHandler()) return;\n\n    clearListDOM();\n\n    // function for rendering typeahead suggestions\n    const render = (item: T): HTMLDivElement => {\n      const itemElement = doc.createElement('div');\n      itemElement.classList.add(classNames.suggestion);\n      itemElement.setAttribute('role', 'option');\n      itemElement.setAttribute('aria-selected', 'false');\n      itemElement.setAttribute('aria-label', display(item));\n      if (templates?.suggestion) {\n        templatify(itemElement, templates.suggestion(item, resultSet));\n      } else {\n        itemElement.textContent = (item[identifier] as string) || '';\n      }\n      return itemElement;\n    };\n\n    // function to render typeahead groups\n    const renderGroup = (groupName: string): HTMLDivElement => {\n      const groupDiv = doc.createElement('div');\n      groupDiv.classList.add(classNames.group);\n      groupDiv.setAttribute('role', 'group');\n      groupDiv.setAttribute('aria-label', groupName);\n      if (templates?.group) {\n        templatify(groupDiv, templates.group(groupName, resultSet));\n      } else {\n        groupDiv.textContent = groupName || '';\n      }\n      return groupDiv;\n    };\n\n    const fragment = doc.createDocumentFragment();\n    const prevGroups: string[] = [];\n\n    // Add header template\n    if (templates?.header) {\n      const headerDiv = doc.createElement('div');\n      headerDiv.classList.add(classNames.header);\n      headerDiv.setAttribute('role', 'presentation');\n      const templateHtml = templatify(headerDiv, templates.header(resultSet));\n      templateHtml && fragment.appendChild(headerDiv);\n    }\n\n    // loop over suggestions\n    for (const [index, item] of resultSet.items.entries()) {\n      if (index === resultSet.limit) break;\n\n      // attach group if available\n      if (item[groupIdentifier] && !prevGroups.includes(item[groupIdentifier] as string)) {\n        prevGroups.push(item[groupIdentifier] as string);\n        const groupDiv = renderGroup(item[groupIdentifier] as string);\n        fragment.appendChild(groupDiv);\n      }\n\n      // attach suggestion\n      const div = render(item);\n      div.addEventListener('click', (ev: MouseEvent): void => {\n        clear();\n        selected = item;\n        input.value = display(item, ev);\n        emitInputEvent();\n      });\n      if (item === selected) {\n        div.classList.add(classNames.selected);\n        div.setAttribute('aria-selected', 'true');\n      }\n      fragment.appendChild(div);\n\n      // highlight matched text\n      config.highlight && hightlight(div, resultSet.query);\n    }\n\n    // Add footer template\n    if (templates?.footer) {\n      const footerDiv = doc.createElement('div');\n      footerDiv.classList.add(classNames.footer);\n      footerDiv.setAttribute('role', 'presentation');\n      const templateHtml = templatify(footerDiv, templates.footer(resultSet));\n      templateHtml && fragment.appendChild(footerDiv);\n    }\n\n    listContainer.appendChild(fragment);\n\n    // update hint if its enabled\n    hint && updateHint(selected || resultSet.items[0]);\n\n    // scroll when not in view\n    listContainer.querySelector(`.${classNames.selected}`)?.scrollIntoView({ block: 'nearest' });\n\n    show();\n  };\n\n  const inputEventHandler = (ev: InputEvent): void => {\n    // Fix: Firefox Android uses insertCompositionText instead of insertText.\n    if (typeof ev.inputType === 'undefined' || (ev.inputType === 'insertCompositionText' && !ev.isComposing)) {\n      return;\n    }\n\n    storedInput = input.value;\n    startFetch();\n  };\n\n  /**\n   * Select the previous item in suggestions\n   */\n  const selectPrev = (ev: KeyboardEvent): void => {\n    const maxLength = resultSet.items.length >= resultSet.limit ? resultSet.limit : resultSet.items.length;\n    // if first item is selected and UP Key is pressed, focus input and restore original input\n    if (selected === resultSet.items[0]) {\n      selected = undefined;\n      input.value = storedInput;\n      return;\n    }\n    // if focus is on input, and UP Key is pressed, select last item\n    if (!selected) {\n      selected = resultSet.items[maxLength - 1];\n    } else {\n      for (let i = maxLength - 1; i > 0; i--) {\n        if (selected === resultSet.items[i] || i === 1) {\n          selected = resultSet.items[i - 1];\n          break;\n        }\n      }\n    }\n\n    input.value = display(selected, ev);\n  };\n\n  /**\n   * Select the next item in suggestions\n   */\n  const selectNext = (ev: KeyboardEvent): void => {\n    const maxLength = resultSet.items.length >= resultSet.limit ? resultSet.limit : resultSet.items.length;\n    // if nothing selected, select the first suggestion\n    if (!selected) {\n      selected = resultSet.items[0];\n      input.value = display(selected, ev);\n      return;\n    }\n    // if we're at the end of the list, go to input box and restore original input\n    if (selected === resultSet.items[maxLength - 1]) {\n      selected = undefined;\n      input.value = storedInput;\n      return;\n    }\n\n    for (let i = 0; i < maxLength - 1; i++) {\n      if (selected === resultSet.items[i]) {\n        selected = resultSet.items[i + 1];\n        break;\n      }\n    }\n\n    input.value = display(selected, ev);\n  };\n\n  const keydownEventHandler = (ev: KeyboardEvent): void => {\n    // if raw input is empty if Esc is hit, clear out everything\n    if (ev.key === 'Escape' || (!input.value.length && !resultSet.items.length)) {\n      return clear();\n    }\n\n    if (resultSet.items.length && (ev.key === 'ArrowUp' || ev.key === 'ArrowDown')) {\n      ev.key === 'ArrowDown' ? selectNext(ev) : selectPrev(ev);\n      update();\n\n      ev.preventDefault();\n      ev.stopPropagation();\n\n      return;\n    }\n\n    const useSelectedValue = function (fallback = false) {\n      if (!selected && fallback && resultSet.items.length) {\n        selected = resultSet.items[0];\n      }\n      if (selected) {\n        clear();\n        input.value = display(selected, ev);\n        emitInputEvent();\n        return selected;\n      }\n    };\n\n    if (ev.key === 'Enter') {\n      preventSubmit && ev.preventDefault();\n      onSubmit(ev, useSelectedValue());\n\n      return;\n    }\n\n    if (ev.key === 'Tab' && isListOpen()) {\n      ev.preventDefault();\n      useSelectedValue(true);\n    }\n  };\n\n  const focusEventHandler = (): void => {\n    if (prefetch && prefetch.when === 'onFocus') {\n      prefetchData();\n    }\n    startFetch();\n  };\n\n  const startFetch = (): void => {\n    clearRemoteDebounceTimer();\n    const val = input.value.replace(/\\s{2,}/g, ' ').trim();\n\n    // empty/default template\n    if (templates?.empty && !val.length) {\n      const emptyHtml = templates.empty(resultSet);\n      resultSet.query = '';\n      if (resultSet.defaultItems?.length) {\n        // inject default suggestions\n        resultSet.items = normalizer(resultSet.defaultItems, identifier) as T[];\n        return update();\n      }\n\n      // inject empty html template only if default suggestions aren't provided\n      clear();\n      clearListDOM();\n      const emptyEl = doc.createElement('div');\n      emptyEl.classList.add(classNames.empty);\n      templatify(emptyEl, emptyHtml);\n      emptyHtml && listContainer.appendChild(emptyEl);\n      return show();\n    }\n\n    if (val.length >= minLen) {\n      resultSet.query = val;\n      calcSuggestions();\n\n      // if remote source exists, first check remote cache before making any query\n      const thumbprint = JSON.stringify(resultSet.query);\n      if (remote && resultSet.items.length < resultSet.limit && (remoteResponseCache[thumbprint] as [])?.length) {\n        calcSuggestions(remoteResponseCache[thumbprint] as []);\n      }\n\n      update(); // update view\n\n      remoteDebounceTimer = window.setTimeout(function (): void {\n        if (resultSet.items.length < resultSet.limit && !fetchInProgress) {\n          fetchDataFromRemote();\n        }\n      }, debounceXHR);\n    } else {\n      resultSet.query = '';\n      clear();\n    }\n  };\n\n  const formatQuery = (ip = '') => {\n    if (config.diacritics) {\n      ip = diacritics(ip);\n    }\n\n    return ip.toLowerCase();\n  };\n\n  const calcSuggestions = (newItems?: T[]): void => {\n    // get suggestions\n    let { suggestions, count }: { suggestions: T[]; count: number } = trie.search(resultSet.query, resultSet.limit);\n\n    if (newItems?.length) {\n      newItems.push(...suggestions); // merge suggestions\n\n      const uniqueItems = {} as Dictionary<T>;\n      newItems.forEach((item) => {\n        uniqueItems[identity(item)] = item;\n      });\n\n      suggestions = Object.values(uniqueItems);\n      count = suggestions.length;\n    }\n\n    // sort by starting letter of the query\n    sortByStartingLetter(suggestions);\n\n    // if suggestions need to be grouped, sort them by group\n    if (groupIdentifier) {\n      sortByGroup(suggestions);\n    }\n\n    // update items with available suggestions\n    resultSet.items = suggestions;\n    resultSet.count = count;\n\n    selected = undefined; // unselect previously calculated/cached suggestion\n    if (autoSelect && resultSet.items.length) {\n      selected = resultSet.items[0];\n    }\n  };\n\n  const fetchDataFromRemote = () => {\n    if (!remote) return;\n\n    fetchInProgress = true;\n    const frozenInput = resultSet.query;\n    const thumbprint = JSON.stringify(frozenInput);\n\n    // check cache, verify input length\n    if (remoteQueryCache[thumbprint] || !resultSet.query.length) {\n      fetchInProgress = false;\n      noSuggestionsHandler(true);\n      return;\n    }\n\n    loader();\n\n    let transformed: T[] = [];\n\n    fetchWrapper\n      .get(\n        (typeof remote.url === 'function' ? remote.url(frozenInput) : remote.url).replace(\n          remote.wildcard || '',\n          frozenInput\n        ),\n        remote?.requestOptions\n      )\n      .then(\n        (data) => {\n          transformed = transform(data) as T[];\n          transformed = normalizer(transformed, identifier) as T[];\n          updateSearchIndex(transformed);\n        },\n        (reject) => {\n          console.error('e05', reject);\n        }\n      )\n      .finally(() => {\n        // cache XHR requests so that same calls aren't made multiple times\n        remoteQueryCache[thumbprint] = true;\n        remoteResponseCache[thumbprint] = transformed || [];\n        fetchInProgress = false;\n        loader();\n        if (transformed.length && resultSet.query.length) {\n          calcSuggestions(transformed);\n          update();\n        }\n\n        // make another request if inputVal exists but is different than the last remote request\n        if (resultSet.query.length && frozenInput !== resultSet.query) {\n          fetchDataFromRemote();\n        }\n        noSuggestionsHandler(true);\n      });\n  };\n\n  /**\n   * Update the search Index with the identifier + dataTokens\n   */\n  function updateSearchIndex(iterable: T[]) {\n    if (!iterable.length) return;\n\n    // add new items to the search index\n    trie.add(iterable, identifier, identity);\n    if (dataTokens) {\n      dataTokens.forEach((token) => {\n        trie.add(iterable, token, identity);\n      });\n    }\n  }\n\n  /**\n   * Sorts array in place giving preference to the starting letter of the query\n   */\n  const sortByStartingLetter = (suggestions: T[]): void => {\n    const query = resultSet.query.toLowerCase();\n    suggestions.sort((one: Dictionary, two: Dictionary) => {\n      const a = (one[identifier] as string).toLowerCase();\n      const b = (two[identifier] as string).toLowerCase();\n\n      const startsWithA = a.startsWith(query);\n      const startsWithB = b.startsWith(query);\n\n      if (startsWithA && startsWithB) {\n        // If both start with the given string, sort by shortest length first\n        return a.length - b.length;\n      }\n      if (startsWithA) {\n        // If only A starts with the given string, it should come first\n        return -1;\n      }\n      if (startsWithB) {\n        // If only B starts with the given string, it should come first\n        return 1;\n      }\n\n      // If neither start with the given string, maintain original order\n      return 0;\n    });\n  };\n\n  /**\n   * Sorts(in-place) array by group\n   */\n  const sortByGroup = (suggestions: T[]) => {\n    suggestions.sort((a: Dictionary, b: Dictionary) => {\n      // if no group identifier was found, do not sort\n      if (!a[groupIdentifier] && !b[groupIdentifier]) return 0;\n      if (!a[groupIdentifier]) {\n        return -1;\n      }\n      if (!b[groupIdentifier]) {\n        return 1;\n      }\n      // sort in ascending order of group name\n      if ((a[groupIdentifier] as string) < (b[groupIdentifier] as string)) {\n        return -1;\n      }\n      if ((a[groupIdentifier] as string) > (b[groupIdentifier] as string)) {\n        return 1;\n      }\n\n      return 0;\n    });\n  };\n\n  /**\n   * Highlights a given text by its pattern\n   * @param Elm The listContainer element\n   * @param pattern the string to highlight\n   */\n  const hightlight = (Elm: HTMLElement, pattern: string): void => {\n    const getRegex = (query: string, wordsOnly: boolean) => {\n      const escapedQuery = escapeRegExp(query);\n      const regexStr = wordsOnly ? '\\\\b(' + escapedQuery + ')\\\\b' : '(' + escapedQuery + ')';\n      return new RegExp(regexStr, 'i');\n    };\n\n    const hightlightTextNode = (textNode: Text) => {\n      let match = regex.exec(textNode.data);\n\n      // check for diacritics if necessary\n      if (config.diacritics && !match) {\n        match = regex.exec(diacritics(textNode.data));\n      }\n\n      const wrapperNode = doc.createElement('span');\n      wrapperNode.className = classNames.highlight;\n\n      if (match) {\n        const patternNode = textNode.splitText(match.index);\n        patternNode.splitText(match[0].length);\n        wrapperNode.appendChild(patternNode.cloneNode(true));\n\n        textNode?.parentNode?.replaceChild(wrapperNode, patternNode);\n      }\n\n      return !!match;\n    };\n\n    const traverse = (el: HTMLElement | ChildNode, hightlightTextNode: (textNode: Text) => boolean) => {\n      const TEXT_NODE_TYPE = 3;\n      let childNode;\n\n      for (let i = 0; i < el.childNodes.length; i++) {\n        childNode = el.childNodes[i];\n\n        if (childNode.nodeType === TEXT_NODE_TYPE) {\n          i += hightlightTextNode(childNode as Text) ? 1 : 0;\n        } else {\n          traverse(childNode, hightlightTextNode);\n        }\n      }\n    };\n\n    const regex = getRegex(pattern, false);\n    pattern && traverse(Elm, hightlightTextNode);\n  };\n\n  /**\n   * injects Hint input element into the DOM\n   * @param inputHint the input hint element\n   */\n  function injectHintEl(inputHint: HTMLInputElement) {\n    ['id', 'name', 'placeholder', 'required', 'aria-label'].forEach((attr) => inputHint.removeAttribute(attr));\n    inputHint.setAttribute('readonly', 'true');\n    inputHint.setAttribute('aria-hidden', 'true');\n    inputHint.style.marginTop = `-${input.offsetHeight + parseInt(computedInputStyle.marginBottom)}px`; // super-impose hint on input\n    inputHint.tabIndex = -1;\n    inputHint.className = classNames.hint;\n\n    input.after(inputHint);\n  }\n\n  /**\n   * Updates the value of hint\n   * @param selectedItem The selected item\n   */\n  const updateHint = (selectedItem: T) => {\n    const rawInput = input.value;\n\n    // if raw string is not part of suggestion, hide the hint\n    if (\n      !rawInput ||\n      display(selectedItem) === rawInput || // if input string is exactly the same as selectedItem\n      formatQuery(display(selectedItem)).indexOf(\n        formatQuery(rawInput)\n          .replace(/\\s{2,}/g, ' ')\n          .trimStart()\n      ) !== 0\n    ) {\n      inputHint.value = '';\n    } else {\n      const item = display(selectedItem);\n      const regex = new RegExp(escapeRegExp(resultSet.query), 'i');\n      let match = regex.exec(item);\n\n      // check for diacritics if necessary\n      if (config.diacritics && !match) {\n        match = regex.exec(diacritics(item));\n      }\n\n      if (match) {\n        inputHint.value = (rawInput.replace(/\\s?$/, '') + item.substring(match[0].length)) as string;\n      }\n    }\n  };\n\n  /**\n   * Creates and appends a template to an HTMLElement\n   * @param El The html element that the template should attach to\n   * @param templateHtml The raw string representation of the html template\n   */\n  const templatify = (El: HTMLElement | DocumentFragment, templateHtml: string) => {\n    const template = doc.createElement('template');\n    template.innerHTML = templateHtml;\n    El.appendChild(template.content);\n    return templateHtml;\n  };\n\n  const blurEventHandler = (): void => {\n    // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n    setTimeout(() => {\n      if (doc.activeElement !== input) {\n        clear();\n      }\n    }, 50);\n  };\n\n  /**\n   * Handle Long clicks\n   */\n  listContainer.addEventListener('mousedown', function (e: Event) {\n    e.stopPropagation();\n    e.preventDefault();\n  });\n\n  /**\n   * Resets the typeahead instance and clears everything\n   * Clears the search index as well as the entire cache\n   * clearLocalSrc?: boolean, if true, clears even the suggestions added via the Local Source\n   * */\n  const reset = (clearLocalSrc?: boolean) => {\n    clear();\n    trie.clear();\n    local && !clearLocalSrc && addToIndex(local);\n    remoteQueryCache = {};\n    remoteResponseCache = {};\n    if (prefetch) {\n      prefetch.done = false;\n    }\n  };\n\n  /**\n   * This function will remove DOM elements, clears cache and removes all event handlers\n   */\n  const destroy = (): void => {\n    clearRemoteDebounceTimer();\n    reset();\n    wrapper.replaceWith(input.cloneNode());\n  };\n\n  // setup event handlers\n  input.addEventListener('keydown', keydownEventHandler);\n  input.addEventListener('input', inputEventHandler as EventListenerOrEventListenerObject);\n  input.addEventListener('blur', blurEventHandler);\n  input.addEventListener('focus', focusEventHandler);\n\n  return {\n    addToIndex,\n    reset,\n    destroy,\n    // trie, // trie exposed only for local tests\n  };\n}\n"],"names":["NOOP","args","escapeRegExp","text","isObject","item","diacritics","txt","normalizer","listItems","identifier","length","x","acc","currentItem","spaceTokenizer","tokenString","get","url","requestOptions","response","handleResponse","data","fetchWrapper","Trie","config","hasDiacritics","root","SENTINEL","tokenize","value","add","identity","node","token","prefix","i","l","uniqueId","find","matches","nodeStack","prefixStack","k","search","query","limit","queryTokens","objArrs","suggestions","currentObj","result","key","count","clear","typeahead","doc","listContainer","debounceXHR","preventSubmit","minLen","hint","autoSelect","templates","trie","groupIdentifier","displayCb","display","onSubmit","dataTokens","transform","local","remoteUrlType","remote","prefetch","classNames","resultSet","remoteQueryCache","remoteResponseCache","selected","remoteDebounceTimer","fetchInProgress","storedInput","addToIndex","updateSearchIndex","input","computedInputStyle","wrapper","parentEl","inputIndex","inputHint","injectHintEl","prefetchData","transformed","reject","show","hide","isListOpen","clearRemoteDebounceTimer","emitInputEvent","noSuggestionsHandler","asyncRender","clearListDOM","notFoundTemplateHtml","renderNotFoundTemplate","html","notFoundEl","templatify","loader","loaderEl","loaderDiv","update","render","itemElement","renderGroup","groupName","groupDiv","fragment","prevGroups","headerDiv","index","div","ev","hightlight","footerDiv","updateHint","inputEventHandler","startFetch","selectPrev","maxLength","selectNext","keydownEventHandler","useSelectedValue","fallback","focusEventHandler","val","emptyHtml","emptyEl","calcSuggestions","thumbprint","fetchDataFromRemote","formatQuery","ip","newItems","uniqueItems","sortByStartingLetter","sortByGroup","frozenInput","iterable","one","two","a","b","startsWithA","startsWithB","Elm","pattern","getRegex","wordsOnly","escapedQuery","regexStr","hightlightTextNode","textNode","match","regex","wrapperNode","patternNode","traverse","el","childNode","attr","selectedItem","rawInput","El","templateHtml","template","blurEventHandler","reset","clearLocalSrc","destroy"],"mappings":"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"}